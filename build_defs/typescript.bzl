load("//build_defs:utils.bzl", "join_paths", "normalize_path")

def _get_transitive_ts_decls(ctx):
  all_deps_declarations = set()
  for extra in ctx.files._additional_d_ts:
    all_deps_declarations += set([extra])
  for dep in ctx.attr.deps:
    if hasattr(dep, "typescript"):
      all_deps_declarations += dep.typescript.transitive_declarations
  return list(all_deps_declarations)

def _basename(ctx, package, root_dir, out_dir, input_file):
  package_prefix = (package + "/") if package else ""
  dot = input_file.short_path.rfind(".")
  basename = input_file.short_path[len(package_prefix):dot]
  basename = basename.replace(root_dir, out_dir)
  return basename

def _compile_ts(ctx):
  """Creates actions to compile TypeScript code.

  Args:
    ctx: The Skylark context.
  """
  ### Collect srcs and outputs.
  srcs = ctx.files.srcs
  transpiled = []
  generated_declarations = []  # d.ts generated by the TypeScript compiler.
  generated_metadata = []
  has_sources = False

  tsconfig = ctx.file.tsconfig

  root_dir = ctx.attr.root_dir or tsconfig.dirname
  out_dir = ctx.attr.out_dir or tsconfig.dirname

  # Compile the sources, if any.
  for src in ctx.attr.srcs:
    # 'x/y.ts' ==> 'x/y.js'
    if src.label.package != ctx.label.package:
      # Sources can be in sub-folders, but not in sub-packages.
      fail("Sources must be in the same package as the ts_library rule, " +
           "but %s is not in %s" % (src.label, ctx.label.package), "srcs")

    for f in src.files:
      has_sources = True
      if not f.short_path.endswith(".d.ts"):
        basename = _basename(ctx, src.label.package, root_dir, out_dir, f)
        transpiled.append(ctx.new_file(basename + ".js"))
        generated_declarations.append(ctx.new_file(basename + ".d.ts"))
        if ctx.attr.write_metadata:
          generated_metadata.append(ctx.new_file(basename + ".metadata.json"))

  input_declarations = _get_transitive_ts_decls(ctx)

  paths = []
  for dep in ctx.attr.deps:
    if dep.typescript.module_name and dep.typescript.root_dir:
      # @ is a special character for worker spawning, so we have to escape that.
      # Unfortunately, escaping with @@ doesn't seem to work on OS X, so we have
      # to use this hack and revert this in tsc-wrapped.
      module_name = dep.typescript.module_name.replace("@", "%%%%%")
      mapped_dir = join_paths(
          "/".join([".." for x in tsconfig.dirname.split("/") if x]),
          ctx.configuration.bin_dir.path,
          dep.typescript.root_dir
      )
      paths += ["--paths", module_name + ":" + mapped_dir]
      paths += ["--paths", module_name + "/*:" + mapped_dir + "/*"]

  if has_sources:
    ctx.action(
      progress_message = "Compiling TypeScript %s" % ctx,
      mnemonic = "TypeScriptCompile",
      inputs = srcs + input_declarations + [tsconfig],
      outputs = transpiled + generated_declarations + generated_metadata,
      executable = ctx.executable.compiler,
      arguments = [
          "--project", tsconfig.path,
          "--rootDir", root_dir,
          "--outDir", join_paths(ctx.configuration.bin_dir.path, out_dir)
      ] + (["--writeMetadata"] if ctx.attr.write_metadata else []) + paths)

  transitive_decls = input_declarations + generated_declarations

  return struct(
    files = set(transpiled),
    runfiles = ctx.runfiles(
        files = list(transpiled),
        collect_default = True,
        collect_data = True,
    ),
    typescript = struct(
      transitive_declarations = transitive_decls + generated_metadata,
      sources = transpiled,
      module_name = ctx.attr.module_name,
      root_dir = out_dir, # Downstream only cares about the artifact
    ),
  )

# ************ #
# ts_library   #
# ************ #

def _ts_library_impl(ctx):
  """
  Implementation of ts_library. Transpiles TypeScript sources to JavaScript, and
  produces .d.ts files for downstream TypeScript dependencies.
  """
  return _compile_ts(ctx)

# See go/typescript/build_defs#ts-library for user documentation.
ts_library = rule(
    _ts_library_impl,
    attrs = {
        "compiler": attr.label(
            default = Label("//:tsc-wrapped_release"),
            cfg = DATA_CFG,
            executable = True,
        ),
        "tsconfig": attr.label(
            allow_files = True,
            cfg = DATA_CFG,
            single_file = True,
        ),
        "srcs": attr.label_list(
            allow_files = FileType([
                ".ts",
                ".tsx",
            ]),
            mandatory = True,
        ),
        "deps": attr.label_list(providers=["typescript"]),
        "data": attr.label_list(
            default = [],
            allow_files = True,
            cfg = DATA_CFG,
        ),
        "_additional_d_ts": attr.label_list(
            allow_files = True,
            default = [],
        ),
        # module_name, root_dir and out_dir are used in path mappings in
        # tsconfig.json. root_dir and out_dir both default to the directory that
        # tsconfig.json resides in.
        "module_name": attr.string(),
        "root_dir": attr.string(default=""),
        "out_dir": attr.string(default=""),
        "write_metadata": attr.bool(default=False),
    },
)

def _ts_ext_declaration_impl(ctx):
  """
  Creates a container for TypeScript d.ts files without type checking.
  """

  return struct(
      files = set(ctx.files.srcs),
      runfiles = ctx.runfiles(files = ctx.files.srcs),
      typescript = struct(
          transitive_declarations = ctx.files.srcs,
          module_name = ctx.attr.module_name,
          root_dir = ctx.attr.root_dir,
      )
  )

ts_ext_declaration = rule(
    _ts_ext_declaration_impl,
    attrs = {
        "srcs": attr.label_list(
            allow_files = FileType([".d.ts"]),
            mandatory = True,
        ),
        "module_name": attr.string(),
        "root_dir": attr.string(),
    }
)
