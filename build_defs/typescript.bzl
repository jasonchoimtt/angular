load("//build_defs:utils.bzl", "join_paths", "normalize_path")

def _get_transitive_ts_decls(ctx):
  all_deps_declarations = set()
  for extra in ctx.files._additional_d_ts:
    all_deps_declarations += set([extra])
  for dep in ctx.attr.deps:
    if hasattr(dep, "typescript"):
      all_deps_declarations += dep.typescript.transitive_declarations
  return list(all_deps_declarations)

def _basename(ctx, package, root_dir, out_dir, input_file):
  package_prefix = (package + "/") if package else ""
  dot = input_file.short_path.rfind(".")
  basename = input_file.short_path[len(package_prefix):dot]
  basename = basename.replace(root_dir, out_dir)
  return basename

def _compile_ts(ctx):
  """Creates actions to compile TypeScript code.

  Args:
    ctx: The Skylark context.
  """
  ### Collect srcs and outputs.
  srcs = ctx.files.srcs
  transpiled = []
  generated_declarations = []  # d.ts generated by the TypeScript compiler.
  generated_metadata = []
  has_sources = False

  tsconfig_input = ctx.file.tsconfig

  root_dir = ctx.attr.root_dir or tsconfig_input.dirname
  out_dir = ctx.attr.out_dir or tsconfig_input.dirname

  # Compile the sources, if any.
  for src in ctx.attr.srcs:
    # 'x/y.ts' ==> 'x/y.js'
    if src.label.package != ctx.label.package:
      # Sources can be in sub-folders, but not in sub-packages.
      fail("Sources must be in the same package as the ts_library rule, " +
           "but %s is not in %s" % (src.label, ctx.label.package), "srcs")

    for f in src.files:
      has_sources = True
      if not f.short_path.endswith(".d.ts"):
        basename = _basename(ctx, src.label.package, root_dir, out_dir, f)
        transpiled.append(ctx.new_file(basename + ".js"))
        generated_declarations.append(ctx.new_file(basename + ".d.ts"))
        if ctx.attr.write_metadata:
          generated_metadata.append(ctx.new_file(basename + ".metadata.json"))

  input_declarations = _get_transitive_ts_decls(ctx)

  tsconfig = ctx.new_file(ctx.label.name + "_tsconfig.json")
  tsconfig_to_workspace = "/".join([".." for x in tsconfig.dirname.split("/") if x])

  paths = {}
  for dep in ctx.attr.deps:
    if dep.typescript.module_name and dep.typescript.root_dir:
      module_name = dep.typescript.module_name
      mapped_dir = join_paths(
          tsconfig_to_workspace,
          ctx.configuration.bin_dir.path,
          dep.typescript.root_dir
      )
      paths[module_name] = [mapped_dir]
      paths[module_name + "/*"] = [mapped_dir + "/*"]

  _write_tsconfig(ctx, tsconfig, tsconfig_input, {
      "compilerOptions": {
          "rootDir": join_paths(tsconfig_to_workspace, root_dir),
          "outDir": join_paths(tsconfig_to_workspace, ctx.configuration.bin_dir.path, out_dir),
          "paths": paths,
          "skipLibCheck": True,
          "stripInternal": False,
      },
      "angularCompilerOptions": {
          "writeMetadata": ctx.attr.write_metadata,
      },
      # Filter out metadata.json
      "files": [join_paths(tsconfig_to_workspace, src.path) for src in srcs + input_declarations if src.path.endswith(".ts")],
  })

  if has_sources:
    has_worker = "tsc-wrapped" in ctx.files.compiler[0].path
    ctx.action(
      progress_message = "Compiling TypeScript %s" % ctx,
      mnemonic = "TypeScriptCompile",
      inputs = srcs + input_declarations + [tsconfig],
      outputs = transpiled + generated_declarations + generated_metadata,
      executable = ctx.executable.compiler,
      arguments = ["@@" + tsconfig.path] if has_worker else ["--project", tsconfig.path],
      execution_requirements = {"supports-workers": "1"})

  transitive_decls = input_declarations + generated_declarations

  return struct(
    files = set(transpiled),
    runfiles = ctx.runfiles(
        files = list(transpiled),
        collect_default = True,
        collect_data = True,
    ),
    typescript = struct(
      transitive_declarations = transitive_decls + generated_metadata,
      sources = transpiled,
      module_name = ctx.attr.module_name,
      root_dir = out_dir, # Downstream only cares about the artifact
    ),
  )

def _write_tsconfig(ctx, out, *contents):
  inputs = []
  arguments = ["--out", out.path]

  for content in contents:
    if type(content) == str:
      arguments += [content]
    elif hasattr(content, 'update'):  # type(content) == dict
      arguments += [str(content).replace('True', 'true').replace('False', 'false')]
    else:
      inputs += [content]
      arguments += ["--file", content.path]

  ctx.action(
      progress_message = "Generating tsconfig.json for %s" % ctx,
      inputs = inputs,
      outputs = [out],
      executable = ctx.executable._merge_json,
      arguments = arguments,
  )

  return out

# ************ #
# ts_library   #
# ************ #

def _ts_library_impl(ctx):
  """
  Implementation of ts_library. Transpiles TypeScript sources to JavaScript, and
  produces .d.ts files for downstream TypeScript dependencies.
  """
  return _compile_ts(ctx)

# See go/typescript/build_defs#ts-library for user documentation.
ts_library = rule(
    _ts_library_impl,
    attrs = {
        "compiler": attr.label(
            default = Label("//:tsc-wrapped_release"),
            cfg = DATA_CFG,
            executable = True,
        ),
        "tsconfig": attr.label(
            allow_files = True,
            cfg = DATA_CFG,
            single_file = True,
        ),
        "srcs": attr.label_list(
            allow_files = FileType([
                ".ts",
                ".tsx",
            ]),
            mandatory = True,
        ),
        "deps": attr.label_list(providers=["typescript"]),
        "data": attr.label_list(
            default = [],
            allow_files = True,
            cfg = DATA_CFG,
        ),
        "_additional_d_ts": attr.label_list(
            allow_files = True,
            default = [],
        ),
        # module_name, root_dir and out_dir are used in path mappings in
        # tsconfig.json. root_dir and out_dir both default to the directory that
        # tsconfig.json resides in.
        "module_name": attr.string(),
        "root_dir": attr.string(default=""),
        "out_dir": attr.string(default=""),
        "write_metadata": attr.bool(default=False),
        "_merge_json": attr.label(
            default = Label("//:merge_json"),
            cfg = DATA_CFG,
            executable = True,
        ),
    },
)

def _ts_ext_declaration_impl(ctx):
  """
  Creates a container for TypeScript d.ts files without type checking.
  """

  return struct(
      files = set(ctx.files.srcs),
      runfiles = ctx.runfiles(files = ctx.files.srcs),
      typescript = struct(
          transitive_declarations = ctx.files.srcs,
          module_name = ctx.attr.module_name,
          root_dir = ctx.attr.root_dir,
      )
  )

ts_ext_declaration = rule(
    _ts_ext_declaration_impl,
    attrs = {
        "srcs": attr.label_list(
            allow_files = FileType([".d.ts"]),
            mandatory = True,
        ),
        "module_name": attr.string(),
        "root_dir": attr.string(),
    }
)
